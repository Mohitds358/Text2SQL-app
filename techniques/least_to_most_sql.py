import os
import google.generativeai as genai
from dotenv import load_dotenv
from langchain_community.utilities import SQLDatabase
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnableAssign
from langchain_google_genai import ChatGoogleGenerativeAI

load_dotenv()
GOOGLE_API_KEY = os.environ.get("GOOGLE_API_KEY")
genai.configure(api_key=GOOGLE_API_KEY)

llm = ChatGoogleGenerativeAI(model="gemini-1.5-pro-latest", temperature=0)

least_to_most_template = """
    You are a data analyst working with a SQL Database. Your task is to answer the user's question about the company's database by writing clean and executable SQL queries.

    First, break down the user query into simpler sub-questions.
    Then, answer each sub-question with an appropriate SQL query.
    Finally, use the results of these sub-questions to answer the main question.

    <SCHEMA>{schema}</SCHEMA>

    Conversation History:
    {chat_history}

    Question: {question}

    Sub-Questions and Answers:
    Sub-Question 1: How many patients are female?
    SQL Query: SELECT COUNT(*) FROM patients WHERE gender = 'F';
    Result: 55

    Final SQL Query:
    SELECT COUNT(*) FROM patients WHERE gender = 'F';

    Final Answer:
    55
"""

prompt = ChatPromptTemplate.from_template(least_to_most_template)


def get_sql_queries(user_query: str, db: SQLDatabase, chat_history: list, schema: str):
    sql_chain = (
            RunnableAssign({
                "schema": lambda args: schema,
                "chat_history": lambda args: chat_history,
                "question": lambda args: user_query,
                "sub_questions_and_answers": lambda args: "",
                "final_sql_query": lambda args: ""
            })
            | prompt
            | llm
            | StrOutputParser()
    )

    raw_queries = sql_chain.invoke({
        "schema": schema,
        "chat_history": chat_history,
        "question": user_query,
        "sub_questions_and_answers": "",
        "final_sql_query": ""
    })

    # Debugging output
    print(f"Raw queries generated by LLM: {raw_queries}")

    return raw_queries


def clean_sql_query(query: str) -> str:
    # Clean up the query from any markdown or code formatting
    query = query.replace("```sql", "").replace("```", "").strip()
    query = "\n".join([line for line in query.split("\n") if not line.strip().startswith("--")])
    return query.strip()


def parse_response(raw_response: str):
    try:
        raw_parts = raw_response.split("Sub-Questions and Answers:")

        if len(raw_parts) < 2:
            raise ValueError("Expected delimiter 'Sub-Questions and Answers:' not found in the response.")

        sub_queries_part = raw_parts[1].strip().split("Final SQL Query:")[0].strip()
        sub_queries = sub_queries_part.split("\n\n")

        final_sql_query_part = raw_parts[1].strip().split("Final SQL Query:")[1].strip()
        final_sql_query = final_sql_query_part.split("Final Answer:")[0].strip()
        final_answer = final_sql_query_part.split("Final Answer:")[1].strip()

        return sub_queries, final_sql_query, final_answer
    except Exception as e:
        print(f"Error parsing response: {e}")
        return [], "", ""


def get_response(user_query: str, db: SQLDatabase, chat_history: list, schema: str):
    try:
        raw_queries = get_sql_queries(user_query, db, chat_history, schema)
        sub_queries, final_sql_query, final_answer = parse_response(raw_queries)

        sub_questions_and_answers = []
        if sub_queries:
            for sub_query in sub_queries:
                if "SQL Query:" in sub_query:
                    query_part = sub_query.split("SQL Query:")[1].strip()
                    query_part = clean_sql_query(query_part)
                    result = db.run(query_part)
                    sub_questions_and_answers.append(f"{sub_query.split('SQL Query:')[0].strip()} Result: {result}")
                    db.session.commit()  # Ensure the command is completed before the next one

        # Generate a natural language explanation
        explanation = f"There are a total of {final_answer} female patients."

        final_response = (
            f"User query: {user_query}\n\n"
            f"SQL Query: {final_sql_query}\n\n"
            f"Answer: {explanation}\n"
        )

        return final_response
    except Exception as e:
        print(f"Error generating response: {e}")
        return "Error generating response"
